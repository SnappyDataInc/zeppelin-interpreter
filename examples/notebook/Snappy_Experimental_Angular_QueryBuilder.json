{"paragraphs":[{"text":"%angular\n<div style=\"background-color:whitesmoke;\">\n<h2><b><span style=\"color:darkblue;\">Experimental : Query Builder Engine</span></b></h2>\n<h3><b><span style=\"color:green;\">Features</span></b></h3>\n<ul>\n<li>A generic codegen for UI components based on common characteristics of user input categories.</li>\n<li>Engine resides in notebook. Depends on Zeppelin's spark and angular interpreters.</li>\n</ul>\n<h3><b><span style=\"color:red;\">Known Issues</span></b></h3>\n<ul>\n<li>Executing paragraphs multiple times results in stale values getting populated.</li>\n<li>Schema selection, does not work with complex data types.</li>\n<li>Parameters are hard coded in side the engine, hence a recompliation (re-executing the following paragraph) is needed.</li>\n<li>Code is diffcult to maintain, debug and hence scale.</li>\n<li>Relies heavily on the ZeppelinContext class</li>\n<li>Was orginally written with Zeppelin 0.7.3 APIs, hence does not utilize the clean angular-scala integration of 0.8.2 APIs.</li>\n</ul>\n<h3><b><span style=\"color:blue;\">References</span></b></h3>\n<ul>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/dynamic_form/intro.html\">Zeppelin 0.8.2 Dynamic Forms</a></li>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/display_system/angular_backend.html\">Zeppelin 0.8.2 Angular Backend</a></li>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/display_system/angular_frontend.html\">Zeppelin 0.8.2 Angular Frontend</a></li>\n</ul>\n\n<h4><i>May the source be with you! </i></h4>\n</div>","user":"anonymous","dateUpdated":"2019-12-18T14:49:20+0530","config":{"colWidth":12,"fontSize":9,"enabled":false,"results":{},"editorSetting":{"language":"scala","editOnDblClick":true,"completionKey":"TAB","completionSupport":false},"editorMode":"ace/mode/undefined","editorHide":true,"tableHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576657570035_-905174291","id":"20191218-135610_1150342491","dateCreated":"2019-12-18T13:56:10+0530","dateStarted":"2019-12-18T14:49:16+0530","dateFinished":"2019-12-18T14:49:16+0530","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:46898","results":{"code":"SUCCESS","msg":[{"type":"ANGULAR","data":"<div style=\"background-color:whitesmoke;\">\n<h2><b><span style=\"color:darkblue;\">Experimental : Query Builder Engine</span></b></h2>\n<h3><b><span style=\"color:green;\">Features</span></b></h3>\n<ul>\n<li>A generic codegen for UI components based on common characteristics of user input categories.</li>\n<li>Engine resides in notebook. Depends on Zeppelin's spark and angular interpreters.</li>\n</ul>\n<h3><b><span style=\"color:red;\">Known Issues</span></b></h3>\n<ul>\n<li>Executing paragraphs multiple times results in stale values getting populated.</li>\n<li>Schema selection, does not work with complex data types.</li>\n<li>Parameters are hard coded in side the engine, hence a recompliation (re-executing the following paragraph) is needed.</li>\n<li>Code is diffcult to maintain, debug and hence scale.</li>\n<li>Relies heavily on the ZeppelinContext class</li>\n<li>Was orginally written with Zeppelin 0.7.3 APIs, hence does not utilize the clean angular-scala integration of 0.8.2 APIs.</li>\n</ul>\n<h3><b><span style=\"color:blue;\">References</span></b></h3>\n<ul>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/dynamic_form/intro.html\">Zeppelin 0.8.2 Dynamic Forms</a></li>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/display_system/angular_backend.html\">Zeppelin 0.8.2 Angular Backend</a></li>\n<li><a href=\"https://zeppelin.apache.org/docs/0.8.2/usage/display_system/angular_frontend.html\">Zeppelin 0.8.2 Angular Frontend</a></li>\n</ul>\n\n<h4><i>May the source be with you! </i></h4>\n</div>"}]}},{"title":"RUN THIS FIRST : Creates the object QueryBuilder used in rest of the paragraphs ( Entire codegen engine resides in this paragraph )","text":"import scala.collection.mutable\n\nimport org.apache.zeppelin.spark.SparkZeppelinContext\n\nimport org.apache.spark.sql._\nimport org.apache.spark.sql.SparkSession\nimport scala.collection.mutable.{ListBuffer, Map}\n\nimport org.apache.spark.sql._\nimport org.apache.spark.SparkContext\n\n/**\n * An utility package for AngularJS code generation and basic query string formation based on user inputs\n * gathered using Zeppelin Notebooks using AngularJS UI controls and some of the Zeppelin APIs.\n * # Uses Zeppelin Context as the inter paragraph data exchange mechanism.\n * # Using AngularBind API of Zeppelin context to limit the access of variables to limited paragraphs.\n */\nobject QueryBuilder {\n\n  // File formats\n  lazy val csv = \"CSV\"\n  lazy val csv_delimiter = \"delimiter\"\n  lazy val csv_charset = \"charset\"\n  lazy val csv_quote = \"quote\"\n  lazy val csv_escape = \"escape\"\n  lazy val csv_comment = \"comment\"\n  lazy val csv_header = \"header\"\n  lazy val csv_inferSchema = \"inferSchema\"\n  lazy val csv_mode = \"mode\"\n  lazy val csv_ignoreLeadingWhiteSpace = \"ignoreLeadingWhiteSpace\"\n  lazy val csv_ignoreTrailingWhiteSpace = \"ignoreTrailingWhiteSpace\"\n  lazy val csv_nullValue = \"nullValue\"\n  lazy val csv_nanValue = \"nanValue\"\n  lazy val csv_positiveInf = \"positiveInf\"\n  lazy val csv_negativeInf = \"negativeInf\"\n  lazy val csv_compressionCodec = \"compression\"\n  lazy val csv_dateFormat = \"dateFormat\"\n  lazy val csv_timestampFormat = \"timestampFormat\"\n  lazy val csv_maxColumns = \"maxColumns\"\n  lazy val csv_maxCharsPerColumn = \"maxCharsPerColumn\"\n  lazy val csv_escapeQuotes = \"escapeQuotes\"\n  lazy val csv_maxMalformedLogPerPartition = \"maxMalformedLogPerPartition\"\n  lazy val csv_quoteAll = \"quoteAll\"\n\n  lazy val prq = \"Parquet\"\n  lazy val prq_merge_schema = \"mergeSchema\"\n  lazy val prq_compression = \"compression\"\n\n  lazy val json = \"JSON\"\n  lazy val json_sampling_ratio = \"samplingRatio\"\n  lazy val json_primitivesAsString = \"primitivesAsString\"\n  lazy val json_prefersDecimal = \"prefersDecimal\"\n  lazy val json_allowComments = \"allowComments\"\n  lazy val json_allowUnquotedFieldNames = \"allowUnquotedFieldNames\"\n  lazy val json_allowSingleQuotes = \"allowSingleQuotes\"\n  lazy val json_allowNumericLeadingZeros = \"allowNumericLeadingZeros\"\n  lazy val json_allowNonNumericNumbers = \"allowNonNumericNumbers\"\n  lazy val json_allowBackslashEscapingAnyCharacter = \"allowBackslashEscapingAnyCharacter\"\n  lazy val json_compressionCodec = \"compression\"\n  lazy val json_parseMode = \"parseMode\"\n  lazy val json_dateFormat = \"dateFormat\"\n  lazy val json_timeStampFormat = \"timeStampFormat\"\n\n  lazy val orc = \"ORC\"\n  lazy val orc_compressionCodec = \"compression\"\n\n  lazy val avro = \"Avro\"\n  lazy val avro_source = \"com.databricks.spark.avro\"\n\n  lazy val xml = \"XML\"\n  lazy val xml_rowtag = \"rowTag\"\n  lazy val xml_source = \"com.databricks.spark.xml\"\n\n  lazy val txt = \"Text\"\n  lazy val txt_header = \"text_header\"\n  lazy val txt_delimiter = \"text_delimiter\"\n\n  // Data sources and parameters\n  lazy val hdfs = \"hdfs\"\n  lazy val hdfs_namenode = \"namenode\"\n  lazy val hdfs_path = \"path\"\n\n  lazy val aws = \"AWS\"\n  lazy val aws_id = \"id\"\n  lazy val aws_secret = \"secret\"\n  lazy val aws_location = \"location\"\n  lazy val aws_accessor = \"accessor\"\n\n  lazy val lfs = \"LFS\"\n  lazy val lfs_path = \"path\"\n\n  lazy val gcs = \"GCS\"\n  lazy val gcs_projID = \"projectid\"\n  lazy val gcs_keyPath = \"keypath\"\n  lazy val gcs_bucket = \"bucket\"\n  lazy val gcs_path = \"path\"\n  lazy val gcs_accessor = \"gs\"\n\n  lazy val adls = \"ADLS\"\n  lazy val adls_storage = \"storageAccount\"\n  lazy val adls_key = \"key\"\n  lazy val adls_container = \"container\"\n  lazy val adls_filepath = \"filepath\"\n  lazy val adls_accessor = \"wasb\"\n  lazy val adls_domain = \".blob.core.windows.net\"\n\n  // Some reusable strings\n  private lazy val fileFormats = List((csv, csv), (prq, prq), (json, json), (orc, orc), (avro, avro), (xml, xml), (txt, txt))\n  private lazy val booleanOpts = List((\"true\", \"true\"), (\"false\", \"false\"))\n  private lazy val sources = List((hdfs, \"Hadoop File System\"), (aws, \"Amazon S3\"), (lfs, \"Local File System\"),\n    (gcs, \"Google Cloud Storage\"), (adls, \"Microsoft Azure Store\"))\n\n  private val dlSlash = \"/\"\n  private val dlColon = \":\"\n  private val dlColonSlash = dlColon + dlSlash + dlSlash\n  private val dlAtRate = \"@\"\n  private val system_default = \"system_default\"\n  private val html = \"html\"\n  private val query = \"query\"\n\n  // AngularJS related element properties and functions\n  private lazy val selectAll = \"selectAll\"\n  //FIXME : overflow parameter for tables not reflecting when set here.\n  private lazy val tableStyle =\n    s\"\"\"\n     <style>\n      table, th, td {\n        border: 1px solid black;\n      }\n      th, td {\n        padding: 2px;\n      }\n     </style>\"\"\"\n\n  private lazy val confirmMessage = s\"\"\"confirm('Values updated successfully.')\"\"\"\n  private lazy val resetMessage = s\"\"\"confirm('Values being reset. Restarting in a new copy of this notebook recommended.')\"\"\"\n  private lazy val confirmOnClickFunction =\n    s\"\"\"\n       |function confirm(message){\n       |  alert(message)\n       |}\n     \"\"\".stripMargin\n  private lazy val btnSubmit = \"submit\"\n  private lazy val btnReset = \"reset\"\n  private lazy val btnText = \"text\"\n  private lazy val btnSuccess = \"btn-success\"\n  private lazy val btnPrimary = \"btn-primary\"\n  private lazy val btnDanger = \"btn-danger\"\n\n  /**\n   * Helper function for generating the buttons related section of the final string to be submitted to Angular.\n   * @param buttons\n   * @return\n   */\n  private def renderButtons(buttons: List[AngularButton]): String = {\n    val render = new StringBuilder()\n    val script = new StringBuilder(s\"\"\"<script>\"\"\")\n    for (b <- buttons) {\n      render ++= s\"\"\"<button type=\"${b.btType}\" class=\"btn ${b.btClass}\" \"\"\"\n      b.btNgClick match {\n        case Some(x) => render ++= s\"\"\"ng-click = \"$x\"\"\"\"\n        case _ =>\n      }\n      (b.btOnClickSignature, b.btOnClickFunction) match {\n        case (Some(x), Some(y)) => render ++= s\"\"\"onClick = \"$x\"\"\"\"\n          script ++= y\n        case (_, _) =>\n      }\n      render ++= s\">${b.btLabel}</button>&emsp;\"\n    }\n    script ++= (s\"\"\"</script>\"\"\")\n    render.toString + script.toString\n  }\n\n  /**\n   * A representation of parameters that need to be passed to the file readers.\n   *\n   * @param name    name of the property as specified in the Spark (or reader library) documentation\n   * @param desc    Description for the label that accompanies the input UI control.\n   * @param default Default value if any, as specified in the Spark (or reader library) documentation\n   * @param opts    List of options in case the property values can be defined in a limited set of known values.\n   * @param secure  Whether parameter captures sensitive information that needs to be obscured on the UI.\n   */\n  case class ParamText(\n      name: String,\n      desc: String,\n      default: String = system_default,\n      opts: Option[List[(String, String)]] = None,\n      secure: Option[String] = None)\n\n  /**\n   * Representation of a AngularJS button.\n   *\n   * @param btType    Type of button (text,submit,reset)\n   * @param btLabel   Text to be populated in the button highlighting its purpose\n   * @param btClass   Class of the button (https://www.w3schools.com/bootstrap/bootstrap_buttons.asp)\n   * @param btNgClick String representation of the code that needs to be executed on click.\n   *                  Used for binding with zeppelin context for now.\n   * @param btOnClickSignature Function that gets registered with the OnClick property of the button.\n   * @param btOnClickFunction Complete function definition that gets added to the \"script\" section of the Angular code.\n   */\n  case class AngularButton(\n      btType: String,\n      btLabel: String,\n      btClass: String,\n      btNgClick: Option[String] = None,\n      btOnClickSignature: Option[String] = None,\n      btOnClickFunction: Option[String] = None\n  )\n\n  /**\n   * Utility function to render list of parameters using AngularJS controls.\n   * @param pList List of ParamText\n   * @param paraIDs\n   * @return\n   */\n  def renderParamList(pList: List[ParamText], paraIDs: List[String]): String = {\n    val s = new StringBuilder()\n    val bind = new StringBuilder()\n    val unbind = new StringBuilder()\n    val labelWidth = 250\n    pList match {\n      case Nil =>\n        s\"\"\"%angular\n            <h4 style=\"color:blue;font-style:italic;\">\n            Current selection does not need any parameters to be initialized.</h4>\"\"\".stripMargin\n      case l : List[ParamText] => for (p <- l) {\n        p.opts match {\n          case Some(x) =>\n            s ++=\n                s\"\"\"<mat-form-field><label for=\"select${p.name}\" style=\"width:${labelWidth}px\">${p.name}\n                    <span style=\"font-style:italic;\" >(default: ${p.default})</span></label>\n                    <select matNativeControl required ng-model=\"${p.name}\">\"\"\"\n            for (m <- x)\n              s ++= s\"\"\"<option value=\"${m._1}\">${m._2}</option>\"\"\" //FIXME:Default using \"selected\" not working.\n            s ++= s\"\"\"</select></mat-form-field><br/>\"\"\"\n            for (para <- paraIDs) {\n              bind ++= s\"\"\"z.angularBind('${p.name}',${p.name},'$para');\"\"\"\n              unbind ++= s\"\"\"z.angularUnbind('${p.name}','$para');\"\"\"\n            }\n\n          case _ =>\n            s ++=\n                s\"\"\"<label style=\"width:${labelWidth}px\" for=\"${p.name}\">${p.desc}</label> <input type=${\n                  p.secure match {\n                    case Some(y) => y\n                    case _ => \"text\"\n                  }\n                } class=\"form-control\" id=\"${p.name}\" ng-model=\"${p.name}\" ng-init=\"${p.name}='${p.default}'\"}\n                </input><br/>\"\"\"\n            for (para <- paraIDs) {\n              bind ++= s\"\"\"z.angularBind('${p.name}',${p.name},'$para');\"\"\"\n              unbind ++= s\"\"\"z.angularUnbind('${p.name}','$para');\"\"\"\n            }\n\n        }\n      }\n\n        s\"\"\"%angular\n        <form class=\"form-inline\">\n        <div>\n            ${s.toString}\n            ${\n          renderButtons(List(AngularButton(btnSubmit, \"Confirm\", btnSuccess, Some(bind.toString), Some(confirmMessage), Some(confirmOnClickFunction)),\n            AngularButton(btnSubmit, \"Reset\", btnDanger, Some(unbind.toString), None, None)))\n        }\n        </div>\n        </form>\n        \"\"\"\n    }\n  }\n\n\n  /**\n   * Function to create the final path string based on user inputs provided for a particular data source.\n   * @param z Zeppelin Context\n   * @param ds\n   * @return\n   */\n  def getPathFromParams(z: SparkZeppelinContext, ds: String): String = ds match {\n    case `hdfs` => hdfs + dlColonSlash + z.angular(hdfs_namenode).asInstanceOf[String] + dlSlash +\n        z.angular(hdfs_path).asInstanceOf[String]\n    case `aws` => z.angular(aws_accessor) + dlColonSlash + z.angular(aws_id).asInstanceOf[String] + dlColon +\n        z.angular(aws_secret).asInstanceOf[String] + dlAtRate + z.angular(aws_location).asInstanceOf[String]\n    case `gcs` => gcs_accessor + dlColonSlash + z.angular(gcs_bucket).asInstanceOf[String] +\n        dlSlash + z.angular(gcs_path).asInstanceOf[String]\n    case `adls` => adls_accessor + dlColonSlash + z.angular(adls_container).asInstanceOf[String] +\n        dlAtRate + z.angular(adls_storage).asInstanceOf[String] +\n        adls_domain + dlSlash + z.angular(adls_filepath).asInstanceOf[String]\n    case `lfs` => z.angular(lfs_path).asInstanceOf[String]\n    case _ => \"\"\n  }\n\n  /**\n   * Set parameters in the Spark Context to allow access without having to expose sensitive string in path.\n   * @param sc Spark Context provided by Zeppelin.\n   * @param z Zepplin Context\n   * @param ds Data source identifier string\n   */\n  def configureDataSourceEnvParams(sc: org.apache.spark.SparkContext, z: SparkZeppelinContext, ds: String): Unit = ds match {\n    case `gcs` =>\n      sc.hadoopConfiguration.set(\"fs.gs.impl\", \"com.google.cloud.hadoop.fs.gcs.GoogleHadoopFileSystem\")\n      sc.hadoopConfiguration.set(\"fs.AbstractFileSystem.gs.impl\", \"com.google.cloud.hadoop.fs.gcs.GoogleHadoopFS\")\n      sc.hadoopConfiguration.set(\"fs.gs.project.id\", z.angular(gcs_projID).asInstanceOf[String])\n      sc.hadoopConfiguration.set(\"google.cloud.auth.service.account.enable\", \"true\")\n      sc.hadoopConfiguration.set(\"google.cloud.auth.service.account.json.keyfile\", z.angular(gcs_keyPath).asInstanceOf[String])\n    case `adls` =>\n      sc.hadoopConfiguration.set(\"fs.wasb.impl\", \"org.apache.hadoop.fs.azure.NativeAzureFileSystem\")\n      sc.hadoopConfiguration.set(\"fs.AbstractFileSystem.wasb.impl\", \"org.apache.hadoop.fs.azure.Wasb\")\n      sc.hadoopConfiguration.set(\"fs.azure\", \"org.apache.hadoop.fs.azure.NativeAzureFileSystem\")\n      sc.hadoopConfiguration.set(\"fs.azure.account.key.\" + z.angular(adls_storage).asInstanceOf[String] + adls_domain, z.angular(adls_key).asInstanceOf[String])\n    case `aws` =>\n      sc.hadoopConfiguration.set(\"fs.\" + z.angular(aws_accessor).asInstanceOf[String] + \".awsAccessKeyId\", z.angular(aws_id).asInstanceOf[String])\n      sc.hadoopConfiguration.set(\"fs.\" + z.angular(aws_accessor).asInstanceOf[String] + \".awsSecretAccessKey\", z.angular(aws_secret).asInstanceOf[String])\n    case _ =>\n  }\n\n  /**\n   * Get list of parameters associated with a file format. Parameters reference from Spark (or reader library) docs.\n   * @param f File format identifier string\n   * @return\n   */\n  def getFileFormatParams(f: String): List[ParamText] = f match {\n    case `csv` => List(\n      ParamText(csv_delimiter, csv_delimiter, \",\"),\n      ParamText(csv_charset, csv_charset, \"UTF-8\"),\n      ParamText(csv_quote, csv_quote,system_default),\n      ParamText(csv_escape, csv_escape,system_default),\n      ParamText(csv_comment, csv_comment),\n      ParamText(csv_header, csv_header, \"false\", Some(booleanOpts)),\n      ParamText(csv_inferSchema, csv_inferSchema, \"false\", Some(booleanOpts)),\n      ParamText(csv_mode, csv_mode, \"DROPMALFORMED\", Some(List((\"DROPMALFORMED\", \"DROPMALFORMED\"),\n        (\"FAILFAST\", \"FAILFAST\"),\n        (\"PERMISSIVE\", \"PERMISSIVE\")))),\n      ParamText(csv_ignoreLeadingWhiteSpace, csv_ignoreLeadingWhiteSpace, \"false\", Some(booleanOpts)),\n      ParamText(csv_ignoreTrailingWhiteSpace, csv_ignoreTrailingWhiteSpace, \"false\", Some(booleanOpts)),\n      ParamText(csv_nullValue, csv_nullValue),\n      ParamText(csv_nanValue, csv_nanValue, \"NaN\"),\n      ParamText(csv_positiveInf, csv_positiveInf, \"Inf\"),\n      ParamText(csv_negativeInf, csv_negativeInf, \"-Inf\"),\n      ParamText(csv_compressionCodec, csv_compressionCodec + \"(or codec)\", \"uncompressed\",\n        Some(List((\"uncompressed\", \"uncompressed\"),\n          (\"bzip2\", \"bzip2\"),\n          (\"deflate\", \"deflate\"),\n          (\"gzip\", \"gzip\"),\n          (\"lz4\", \"lz4\"),\n          (\"snappy\", \"snappy\")\n        ))),\n      ParamText(csv_dateFormat, csv_dateFormat, \"yyyy-MM-dd\"),\n      ParamText(csv_timestampFormat, csv_timestampFormat),//FIXME : default parsing issue yyyy-MM-dd'T'HH:mm:ss.SSSZZ\n      ParamText(csv_maxColumns, csv_maxColumns, \"20480\"),\n      ParamText(csv_maxCharsPerColumn, csv_maxCharsPerColumn, \"-1\"),\n      ParamText(csv_escapeQuotes, csv_escapeQuotes, \"true\", Some(booleanOpts)),\n      ParamText(csv_maxMalformedLogPerPartition, csv_maxMalformedLogPerPartition, \"10\"),\n      ParamText(csv_quoteAll, csv_quoteAll, \"false\", Some(booleanOpts))\n    )\n    case `prq` => List(ParamText(prq_merge_schema,\"Merge Schema\",\"false\",Some(booleanOpts)),\n      ParamText(prq_compression,prq_compression,\"uncompressed\",\n        Some(List((\"uncompressed\",\"uncompressed\"),\n          (\"snappy\", \"snappy\"),\n          (\"gzip\", \"gzip\"),\n          (\"lzo\",\"lzo\")\n        ))))\n    case `txt` => List(ParamText(txt_header, \"Header in Text file\", \"true\", Some(booleanOpts)),\n      ParamText(txt_delimiter, \"Delimiter in Text File\", \",\"))\n    case `xml` => List(ParamText(xml_rowtag, \"Row Tag in XML file\", \"breakfast_menu\"))\n    case `json` => List(ParamText(json_sampling_ratio,json_sampling_ratio,\"1.0\"),\n      ParamText(json_primitivesAsString,json_primitivesAsString,\"false\",Some(booleanOpts)),\n      ParamText(json_prefersDecimal,json_prefersDecimal,\"false\",Some(booleanOpts)),\n      ParamText(json_allowComments,json_allowComments,\"false\",Some(booleanOpts)),\n      ParamText(json_allowUnquotedFieldNames,json_allowUnquotedFieldNames,\"false\",Some(booleanOpts)),\n      ParamText(json_allowSingleQuotes,json_allowSingleQuotes,\"true\",Some(booleanOpts)),\n      ParamText(json_allowBackslashEscapingAnyCharacter,json_allowBackslashEscapingAnyCharacter,\"false\",Some(booleanOpts)),\n      ParamText(json_compressionCodec, json_compressionCodec, \"uncompressed\",\n        Some(List((\"uncompressed\", \"uncompressed\"),\n          (\"bzip2\", \"bzip2\"),\n          (\"deflate\", \"deflate\"),\n          (\"gzip\", \"gzip\"),\n          (\"lz4\", \"lz4\"),\n          (\"snappy\", \"snappy\")\n        ))),\n      ParamText(json_parseMode, json_parseMode, \"DROPMALFORMED\", Some(List((\"DROPMALFORMED\", \"DROPMALFORMED\"),\n        (\"FAILFAST\", \"FAILFAST\"),\n        (\"PERMISSIVE\", \"PERMISSIVE\")))),\n      ParamText(json_dateFormat,json_dateFormat),\n      ParamText(json_timeStampFormat,json_timeStampFormat)\n    )\n    case `orc` => List(ParamText(orc_compressionCodec,orc_compressionCodec,\"snappy\",\n      Some(List((\"snappy\",\"snappy\"),\n        (\"snappy\", \"snappy\"),\n        (\"uncompressed\",\"uncompressed\"),\n        (\"zlib\", \"zlib\"),\n        (\"lzo\",\"lzo\")\n      ))))\n    case _ => List()\n  }\n\n  /**\n   * Get the list of data sources currently supported by the functions.\n   * @return\n   */\n  def getDataSources: List[(String, String)] = sources\n\n  /**\n   * Get parameters associated with a particular data source.\n   * @param d String identifier for data source.\n   * @return\n   */\n  def getDataSourceParams(d: String): List[ParamText] = d match {\n    case `hdfs` => List(ParamText(hdfs_namenode, \"HDFS Name node\", \"localhost:9000\"), ParamText(hdfs_path, \"Path of file in HDFS\", \"\"))\n    case `aws` => List(ParamText(aws_id, \"S3 access ID\", \"\", None, Some(\"password\")), ParamText(aws_secret, \"S3 access secret\", \"\", None, Some(\"password\"))\n      , ParamText(aws_location, \"S3 bucket location\", \"\"),ParamText(aws_accessor,\"AWS Accessor\",\"s3a\"))\n    case `adls` => List(ParamText(adls_storage, \"Azure Storage Account\", \"\", None, Some(\"password\")), ParamText(adls_container, \"Azure Container\", \"\"),\n      ParamText(adls_key, \"Azure Key\", \"\"), ParamText(adls_filepath, \"Azure File path in the container\", \"\"))\n    case `gcs` => List(ParamText(gcs_projID, \"GCS Project ID\", \"\", None, Some(\"password\")), ParamText(gcs_keyPath, \"Path of Key File\", \"\", None, Some(\"password\")),\n      ParamText(gcs_bucket, \"GCS Bucket Name\", \"\"), ParamText(gcs_path, \"File path in the GCS bucket\", \"\"))\n    case `lfs` => List(ParamText(lfs_path, \"Path on the local file system\", \"\"))\n    case _ => List()\n  }\n\n  /**\n   * Get the list of file formats currently supported by functions.\n   * @return\n   */\n  def getFileFormats: List[(String, String)] = fileFormats\n\n  /**\n   * Get the string that needs to be passed as the options field in Query being submitted to spark.read.\n   * @param ff file format identifier string\n   * @param z Zeppelin Context\n   * @return\n   */\n  def getFileFormatOptionsForSparkReader(ff: String, z: SparkZeppelinContext): Predef.Map[String, String] = {\n    val opts = mutable.Map.empty[String, String]\n    getFileFormatParams(ff) match {\n      case Nil =>\n      case x: List[ParamText] =>\n        x.foreach(p => z.angular(p.name).asInstanceOf[String] match {\n          case null => opts += (p.name -> p.default)\n          case `system_default` =>\n          case _ => opts += (p.name -> z.angular(p.name).asInstanceOf[String])\n        })\n    }\n    opts.toMap\n  }\n\n  /**\n   * Get the string that needs to be passed as the options field in Query being submitted to SnappySession.\n   * @param ff File format identifier string\n   * @param z Zeppelin Context\n   * @return\n   */\n  def getFileFormatOptionsForSnappy(ff: String, z: SparkZeppelinContext): String = {\n    val opts = new scala.collection.mutable.ListBuffer[String]\n    getFileFormatParams(ff) match {\n      case Nil =>\n      case x : List[ParamText] => x.foreach(p =>\n         z.angular(p.name).asInstanceOf[String] match {\n          case null => p.default match {\n              case `system_default` =>\n              case _ => opts += s\"\"\"${p.name} '${p.default}'\"\"\"\n          }\n          \n          \n          case _ => opts += s\"${p.name} '${z.angular(p.name).asInstanceOf[String]}'\"\n        })\n      }\n    opts.toList.mkString(\",\")\n  }\n\n  /**\n   * Generate angular code of a table for schema with checkboxes for selection.\n   * @param z Zeppelin Context\n   * @param df Data frame from which schema will be inferred.\n   * @param paraIDs Zeppelin paragraph with which these variables need to be bound.\n   * @return\n   */\n  def generateTabularSchema(z: SparkZeppelinContext, df: org.apache.spark.sql.DataFrame, paraIDs: List[String]): String = {\n    val cols = scala.collection.mutable.ListBuffer[(String, String, String)]()\n    val jsTableName = \"TabularSchema\"\n    for (s <- df.schema) {\n      cols += ((s.name.toString, s.dataType.toString, s.nullable.toString))\n    }\n    val s = new StringBuilder()\n    val bindCheckboxes = new StringBuilder()\n    val unbind = new StringBuilder()\n    for (c <- cols) {\n      s ++=\n          s\"\"\"\n            <tr>\n            <td style=\"text-align:center\"><input type=\"checkbox\" ng-model=\"${c._1}\"/></td>\n            <td style=\"text-align:left\">${c._1}</td>\n            <td style=\"text-align:left\">${c._2.replaceAll(\"Type\", \"\").toLowerCase}</td>\n            <td style=\"text-align:center\">${c._3}</td>\n            </tr>\n            \"\"\"\n      for (para <- paraIDs) {\n        bindCheckboxes ++= s\"\"\"z.angularBind('${c._1}',${c._1},'$para');\"\"\"\n        unbind ++= s\"\"\"z.angularUnbind('${c._1}','$para');\"\"\"\n      }\n    }\n\n    for (para <- paraIDs) {\n      bindCheckboxes ++= s\"\"\"z.angularBind('${selectAll}',${selectAll},'$para');\"\"\"\n      unbind ++= s\"\"\"z.angularUnbind('${selectAll}','$para');\"\"\"\n    }\n\n    val fnName = \"updateAll\"\n    val updateAllFunction =\n      s\"\"\"function $fnName(select){\n           var checkBoxes = document.getElementsByTagName(\"INPUT\");\n           for (var i = 0; i < checkBoxes.length; i++) {\n            checkBoxes[i].checked = select;\n           }\n         }\"\"\"\n\n    s\"\"\"%angular\n        $tableStyle\n        <input type=\"checkbox\" ng-model=\"${selectAll}\">Select All</input>\n        <h4> OR select a subset using the following table. </h4>\n        <div style=\"height:300px;overflow:auto\">\n        <table cellspacing=\"0\" rules=\"all\" id=$jsTableName style=\"border-collapse: collapse;\">\n        <tr>\n            <th style=\"width:120px;text-align:center\">Import</th>\n            <th style=\"width:120px;text-align:center\">Column Name</th>\n            <th style=\"width:120px;text-align:center\">Type</th>\n            <th style=\"width:120px;text-align:center\">Nullable</th>\n        </tr>\n        ${s.toString}\n        </table>\n        </div>\n        </br>\n        <br/>\n        ${\n      renderButtons(List(AngularButton(btnSubmit, \"Confirm\", btnSuccess, Some(bindCheckboxes.toString), Some(confirmMessage), Some(confirmOnClickFunction)),\n        AngularButton(btnReset, \"Reset\", btnDanger, Some(unbind.toString), Some(fnName + \"(false)\"), Some(updateAllFunction))))\n    }\n        \"\"\"\n  }\n\n  /**\n   * This function became necessary to tackle the inconsistent response type being derived from Zeppelin context.\n   * @param v\n   * @tparam T\n   * @return\n   */\n  private def typeToBool[T](v: T) = v match {\n    case _: Boolean => v.asInstanceOf[Boolean]\n    case _ => v.asInstanceOf[String] match {\n      case \"true\" => true\n      case _ => false\n    }\n  }\n\n  /**\n   * Generate a table for existing schema and text boxes that allow user to update schema before final query formation.\n   * @param z Zeppelin Context\n   * @param df Data Frame from which schema will be inferred.\n   * @param paraIDs List of Zeppelin notebook paragraphs with which these variables should be bound.\n   * @return\n   */\n  def generateSchemaSelector(z: SparkZeppelinContext, df: org.apache.spark.sql.DataFrame, paraIDs: List[String]): String = {\n    df.schema.isEmpty match {\n      case true => \"Empty Dataframe provided. No schema to be rendered.\"\n      case _ =>\n        val cols = new StringBuilder()\n        val bind = new StringBuilder()\n        val unbind = new StringBuilder()\n        for (s <- df.schema) {\n          (typeToBool(z.angular(s.name)),typeToBool(z.angular(selectAll))) match {\n            case (true,_) | (_,true) => {\n              cols ++=\n                  s\"\"\"\n                    <tr>\n                    <td style=\"text-align:left\">${s.name.toString}</td>\n                    <td style=\"text-align:left\">\n                        ${s.dataType.toString.replaceAll(\"Type\", \"\").toLowerCase}\n                    </td>\n                    <td style=\"text-align:center\">${s.nullable.toString}</td>\n                    <td> <input type=\"text\" class=\"form-control\" ng-model=\"${s.name.toString + \"_name\"}\"\n                         ng-init=\"${s.name.toString + \"_name\"}='${s.name.toString}'\" value=\"${s.name.toString}\">\n                         </input></td>\n                    <td> <input type=\"text\" class=\"form-control\" ng-model=\"${s.name.toString + \"_dataType\"}\"\n                         ng-init=\"${s.name.toString + \"_dataType\"}=\n                         '${s.dataType.toString.replaceAll(\"Type\", \"\").toLowerCase}'\"\n                         value=\"${s.dataType.toString.replaceAll(\"Type\", \"\").toLowerCase}\">\n                         </input> </td>\n                    <td><input type=\"text\" class=\"form-control\" ng-model=\"${s.name.toString + \"_nullable\"}\"\n                         ng-init=\"${s.name.toString + \"_nullable\"}='${s.nullable.toString}'\" value=\"${s.nullable.toString}\">\n                    </input> </td>\n                    </tr>\"\"\"\n                      for (para <- paraIDs) {\n                        bind ++=\n                            s\"\"\"z.angularBind('${s.name.toString + \"_name\"}',${s.name.toString + \"_name\"},'$para');\n                        z.angularBind('${s.name.toString + \"_dataType\"}',${s.name.toString + \"_dataType\"},'$para');\n                        z.angularBind('${s.name.toString + \"_nullable\"}',${s.name.toString + \"_nullable\"},'$para');\n                        \"\"\"\n                      }\n                    }\n                    case (_,_) =>\n                  }\n                  for (para <- paraIDs) {\n                    unbind ++=\n                        s\"\"\"z.angularUnbind('${s.name.toString + \"_name\"}','$para');\n                        z.angularUnbind('${s.name.toString + \"_dataType\"}','$para');\n                        z.angularUnbind('${s.name.toString + \"_nullable\"}','$para');\n                        z.angularUnbind('${selectAll}','$para')\"\"\"\n                  }\n                }\n\n                s\"\"\"%angular\n                    $tableStyle\n                    <div style=\"height:300px;overflow:auto\">\n                    <table cellspacing=\"0\" rules=\"all\" id=\"SchemaSelector\" style=\"border-collapse: collapse;\">\n                        <tr>\n                             <th style=\"width:240px;text-align:center\" colspan=\"3\">Inferred from data</th>\n                             <th style=\"width:240px;text-align:center\" colspan=\"3\">[Optional] User specified</th>\n                        <tr>\n                        <tr>\n                            <th style=\"width:120px;text-align:center\">Column Name</th>\n                            <th style=\"width:60px;text-align:center\">Type</th>\n                            <th style=\"width:60px;text-align:center\">Nullable</th>\n                            <th style=\"width:120px;text-align:center\">Column Name</th>\n                            <th style=\"width:60px;text-align:center\">Type</th>\n                            <th style=\"width:60px;text-align:center\">Nullable</th>\n                        </tr>\n                        ${cols.toString}\n                    </table>\n                    </div>\n                    <br/>\n                    ${\n                  renderButtons(List(AngularButton(btnSubmit, \"Confirm\", btnSuccess, Some(bind.toString),\n                    Some(confirmMessage), Some(confirmOnClickFunction)),\n                    AngularButton(btnReset, \"Reset\", btnDanger, Some(unbind.toString), Some(resetMessage), Some(confirmOnClickFunction))))\n                }\n        \"\"\"\n    }\n  }\n\n  /**\n   * Generate the projection based on schema.\n   * @param df Data frame from which schema will be inferred.\n   * @param z Zeppelin Context\n   * @return\n   */\n  def getProjectionFromScehma(df: org.apache.spark.sql.DataFrame, z: SparkZeppelinContext): String = {\n    val p = new scala.collection.mutable.ListBuffer[String]()\n    for (s <- df.schema) {\n      if (z.angular(s.name.toString + \"_name\").asInstanceOf[String] != null) {\n        p += List(z.angular(s.name.toString + \"_name\").asInstanceOf[String],\n          z.angular(s.name.toString + \"_dataType\").asInstanceOf[String],\n          if (z.angular(s.name.toString + \"_nullable\").asInstanceOf[String] == \"false\")\n            \"NOT NULL\" else \"NULL\").mkString(\" \")\n      }\n    }\n    \"(\" + p.toList.mkString(\",\") + \")\"\n  }\n\n  /**\n   * Combines all parameters and options string to generate the final query to be executed for creation\n   * of the external table.\n   * @param z Zeppelin context\n   * @param df Dataframe\n   * @return The final query that will be executed for creation of the external table representing the data.\n   */\n  def getCreateExternalTableQuery(z: SparkZeppelinContext, df: org.apache.spark.sql.DataFrame): String = {\n    val space = \" \"\n    // TODO: Confirm the selective projection creation from file formats and apply it here.\n    \"CREATE EXTERNAL TABLE\" + space + z.get(\"dataset\").asInstanceOf[String] + space + \"USING\" + space +\n        (z.get(\"fileFormat\").asInstanceOf[String] match {\n          case `avro` => avro_source\n          case `xml` => xml_source\n          case f => f\n        }) + space +\n        \"OPTIONS (\" + s\"\"\"path '${z.get(\"path\")}' \"\"\" +\n          (getFileFormatOptionsForSnappy(z.get(\"fileFormat\").asInstanceOf[String], z) match {\n            case \"\" => \"\"\n            case x: String => \",\" + x\n          }) +\n        \")\"\n  }\n}","user":"anonymous","dateUpdated":"2019-12-18T14:51:42+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","editorHide":true,"title":true,"tableHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576644124372_1441075819","id":"20191218-101204_1892531784","dateCreated":"2019-12-18T10:12:04+0530","dateStarted":"2019-12-18T12:35:08+0530","dateFinished":"2019-12-18T12:35:08+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46899"},{"title":"Step 1 : Select the data source and file format","text":"%spark\nz.put(\"dataSource\",z.select(\"Data Source\", QueryBuilder.getDataSources))\nz.put(\"fileFormat\",z.select(\"File Format\", QueryBuilder.getFileFormats))\nz.run(\"20191218-112106_1971101888\")\nz.run(\"20191218-113212_672513683\")","user":"anonymous","dateUpdated":"2019-12-18T13:35:03+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","runOnSelectionChange":true,"editorHide":true,"title":true},"settings":{"params":{"File Format":"Text","Data Source":"hdfs"},"forms":{"Data Source":{"type":"Select","options":[{"value":"hdfs","displayName":"Hadoop File System","$$hashKey":"object:47030"},{"value":"AWS","displayName":"Amazon S3","$$hashKey":"object:47031"},{"value":"LFS","displayName":"Local File System","$$hashKey":"object:47032"},{"value":"GCS","displayName":"Google Cloud Storage","$$hashKey":"object:47033"},{"value":"ADLS","displayName":"Microsoft Azure Store","$$hashKey":"object:47034"}],"name":"Data Source","displayName":"Data Source","defaultValue":"","hidden":false,"$$hashKey":"object:47014"},"File Format":{"type":"Select","options":[{"value":"CSV","displayName":"CSV","$$hashKey":"object:47041"},{"value":"Parquet","displayName":"Parquet","$$hashKey":"object:47042"},{"value":"JSON","displayName":"JSON","$$hashKey":"object:47043"},{"value":"ORC","displayName":"ORC","$$hashKey":"object:47044"},{"value":"Avro","displayName":"Avro","$$hashKey":"object:47045"},{"value":"XML","displayName":"XML","$$hashKey":"object:47046"},{"value":"Text","displayName":"Text","$$hashKey":"object:47047"}],"name":"File Format","displayName":"File Format","defaultValue":"","hidden":false,"$$hashKey":"object:47015"}}},"apps":[],"jobName":"paragraph_1576647189640_1240471538","id":"20191218-110309_1680181163","dateCreated":"2019-12-18T11:03:09+0530","dateStarted":"2019-12-18T13:35:03+0530","dateFinished":"2019-12-18T13:35:04+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46900"},{"title":"Step 2.a : Provide Data Source parameters and Confirm","text":"%spark\nprintln(QueryBuilder.renderParamList(QueryBuilder.getDataSourceParams(z.get(\"dataSource\").asInstanceOf[String]),List(\"20191218-113758_1221161887\")))","user":"anonymous","dateUpdated":"2019-12-18T13:35:55+0530","config":{"colWidth":6,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","editorHide":true,"title":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576648932090_670267766","id":"20191218-113212_672513683","dateCreated":"2019-12-18T11:32:12+0530","dateStarted":"2019-12-18T13:35:04+0530","dateFinished":"2019-12-18T13:35:04+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46901"},{"title":"Step 2.b : Provide File Format parameters and Confirm","text":"%spark\nprintln(QueryBuilder.renderParamList(QueryBuilder.getFileFormatParams(z.get(\"fileFormat\").asInstanceOf[String]),List(\"20191218-113758_1221161887\")))","user":"anonymous","dateUpdated":"2019-12-18T13:20:48+0530","config":{"colWidth":6,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","editorHide":true,"title":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576648266723_1000646754","id":"20191218-112106_1971101888","dateCreated":"2019-12-18T11:21:06+0530","dateStarted":"2019-12-18T13:35:03+0530","dateFinished":"2019-12-18T13:35:04+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46902"},{"title":"Step 3 : Preview Data","text":"%spark\nQueryBuilder.configureDataSourceEnvParams(sc,z,z.get(\"dataSource\").asInstanceOf[String]) \nval df = spark.read.format(z.get(\"fileFormat\").asInstanceOf[String]).options(QueryBuilder.getFileFormatOptionsForSparkReader(z.get(\"fileFormat\").asInstanceOf[String],z)).load(QueryBuilder.getPathFromParams(z,z.get(\"dataSource\").asInstanceOf[String]))\nz.put(\"path\",QueryBuilder.getPathFromParams(z,z.get(\"dataSource\").asInstanceOf[String]))\nz.show(df)\n","user":"anonymous","dateUpdated":"2019-12-18T13:20:54+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{"0":{"graph":{"mode":"table","height":300,"optionOpen":false,"setting":{"table":{"tableGridState":{},"tableColumnTypeState":{"names":{"C_CUSTKEY":"string","C_NAME":"string","C_ADDRESS":"string","C_NATIONKEY":"string","C_PHONE":"string","C_ACCTBAL":"string","C_MKTSEGMENT":"string","C_COMMENT":"string"},"updated":false},"tableOptionSpecHash":"[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]","tableOptionValue":{"useFilter":false,"showPagination":false,"showAggregationFooter":false},"updated":false,"initialized":false}},"commonSetting":{}}}},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","title":true,"editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576649278574_15305683","id":"20191218-113758_1221161887","dateCreated":"2019-12-18T11:37:58+0530","dateStarted":"2019-12-18T12:04:37+0530","dateFinished":"2019-12-18T12:04:37+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46903"},{"title":"Step 4 : Select Columns to be imported and Confirm","text":"%spark\nprintln(QueryBuilder.generateTabularSchema(z,df,List(\"20191218-115831_1621811561\")))","user":"anonymous","dateUpdated":"2019-12-18T13:57:45+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","title":true,"editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576650178128_-1375451817","id":"20191218-115258_122346975","dateCreated":"2019-12-18T11:52:58+0530","dateStarted":"2019-12-18T13:21:12+0530","dateFinished":"2019-12-18T13:21:12+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46904"},{"title":"Step 5 : Modify schema and Confirm","text":"%spark\nprintln(QueryBuilder.generateSchemaSelector(z,df,List(\"20191218-120159_642379905\")))","user":"anonymous","dateUpdated":"2019-12-18T13:57:51+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","title":true,"editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576650511554_1408976700","id":"20191218-115831_1621811561","dateCreated":"2019-12-18T11:58:31+0530","dateStarted":"2019-12-18T13:02:08+0530","dateFinished":"2019-12-18T13:02:08+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46905"},{"title":"Step 6 : View the final Query built using the provided parameters","text":"%spark\nprintln(QueryBuilder.getCreateExternalTableQuery(z,df))\n","user":"anonymous","dateUpdated":"2019-12-18T13:28:14+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","editorHide":true,"title":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576650719162_-1671656015","id":"20191218-120159_642379905","dateCreated":"2019-12-18T12:01:59+0530","dateStarted":"2019-12-18T12:35:17+0530","dateFinished":"2019-12-18T12:35:17+0530","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:46906"},{"text":"%spark\nimport org.apache.zeppelin.display.angular.notebookscope._\nimport AngularElem._\nAngularElem.disassociate\n\nz.remove(\"fileFormat\")\nz.remove(\"dataSource\")\nz.remove(\"path\")","user":"anonymous","dateUpdated":"2019-12-18T14:51:30+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala","title":true,"tableHide":false,"editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576660793581_458901911","id":"20191218-144953_811424246","dateCreated":"2019-12-18T14:49:53+0530","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:47622","dateFinished":"2019-12-18T14:51:24+0530","dateStarted":"2019-12-18T14:51:24+0530","errorMessage":"","title":"Step 7: Clear all the angular bindings and clean Zeppelin Context"},{"text":"%spark\n","user":"anonymous","dateUpdated":"2019-12-18T14:50:23+0530","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1576660823170_2115132149","id":"20191218-145023_495609466","dateCreated":"2019-12-18T14:50:23+0530","status":"READY","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:47703"}],"name":"Snappy/Experimental_Angular_QueryBuilder","id":"2EXF8S6ST","noteParams":{},"noteForms":{},"angularObjects":{"md:shared_process":[],"angular:shared_process":[],"spark:shared_process":[{"name":"C_NATIONKEY","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"selectAll","object":false,"noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_ADDRESS","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_NAME","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_PHONE","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_ACCTBAL","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_COMMENT","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_MKTSEGMENT","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"C_CUSTKEY","noteId":"2EXF8S6ST","paragraphId":"20191218-115831_1621811561"},{"name":"charset","object":"UTF-8","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"ignoreTrailingWhiteSpace","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"positiveInf","object":"Inf","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"dateFormat","object":"yyyy-MM-dd","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"escapeQuotes","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"nanValue","object":"NaN","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"negativeInf","object":"-Inf","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"inferSchema","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"nullValue","object":"system_default","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"maxColumns","object":"20480","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"mode","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"path","object":"/opt/TIB_compute_1.1.1_linux/quickstart/src/main/resources/customer_with_headers.csv","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"ignoreLeadingWhiteSpace","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"maxMalformedLogPerPartition","object":"10","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"quote","object":"system_default","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"delimiter","object":",","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"header","object":"true","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"timestampFormat","object":"system_default","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"comment","object":"system_default","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"maxCharsPerColumn","object":"-1","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"compression","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"quoteAll","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"},{"name":"escape","object":"system_default","noteId":"2EXF8S6ST","paragraphId":"20191218-113758_1221161887"}]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}